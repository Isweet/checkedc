% !Tex root = checkedc.tex

\chapter{The \arrayptrT Type}
\label{chapter:array-ptrs}

This chapter introduces the \arrayptrT type. This is a pointer
type which points to an element of an array of type \var{T} values.
A variable of type \arrayptrT that is used to access memory must have an
associated declaration of the valid bounds for the variable. When values
of type \arrayptrT are used to read or write memory, they must be non-null
and in bounds. These criteria are checked at runtime if necessary. Unlike
the \ptrT type, pointer arithmetic is allowed on these types. The resulting
pointers do not need to be in bounds.

We introduce the following new keyword for declaring \arrayptrT types.

\begin{lstlisting}
  _Array_ptr
\end{lstlisting}

The all-lowercase version of this declaration is \lstinline{array_ptr}.

Here are  examples of declarations using \arrayptrT types. These declare variables that
are all pointers to integers:
\begin{lstlisting}
int *p;
array_ptr<int> s;
\end{lstlisting}

The new checked pointer types can have \keyword{const} and \keyword{volatile}
modifiers, just like unchecked pointer types.   They can be applied to the type
of the object to which the pointers points or to the pointer itself.  Here are examples
of pointers to constant integers:

\begin{lstlisting}
const int *p;
array_ptr<const int> r;
\end{lstlisting}

A pointer to a constant integer cannot be used to modify the value of
the integer.

Here are examples of constant pointers to modifiable integers:

\begin{lstlisting}
int x;
int *const p = &x;
const array_ptr<int> r = &x;
\end{lstlisting}

Array pointers (\arrayptrT) of function types are not allowed. Functions have
no size associated with them, so bounds checking pointers to them does not
make sense.  Programmers should use \ptrT instead:

\begin{lstlisting}
typedef array_ptr<int (int x, int y)> callback_fn; // illegal
typedef ptr<int (int x, int y)> callback_ptr;      // legal
\end{lstlisting}

\section{Operations}

The following operations involving \arrayptrT values are allowed:

\begin{itemize}
\item
  Indirection: the \code{*} operator can be applied to a value of type
  \arrayptrT. It produces a value of type \var{T}. \ins{What about those without bounds?}
\item
  Array reference: the \code{[]} operator can be applied to a
  value of type \arrayptrT.
  \var{e1}\lstinline|[|\var{e2}\lstinline|]| is equivalent to
  \lstinline|*(|\var{e1} \lstinline|+| \var{e2}\lstinline|)|.
\item
  Assignment: two pointers of the same type can be assigned.
\item
  Adding or subtracting a pointer type and an integer. This is allowed
  \arrayptrT\ types.
\item
  Pointers to objects of the same type can be compared for equality or
  inequality. The pointers do not have to be the same kind of pointer.
  To support reasoning about program behavior, the result of comparing
  pointers to different objects must be defined.  Checked pointers can also
  be compared for equality or inequality with \code{0} and \void\ pointers,
  just like unchecked pointers.
\item
  Pointers to objects of the same type can be compared relationally. Relational comparisons are the
  \lstinline|<|, \lstinline|<=|, \lstinline|>|, \lstinline|>=| operators. The pointers do not have
  to be
  the same kind of pointer. To support bounds checking and reasoning about program behavior, the
  result of comparing pointers to different objects must be defined.
  Section~\ref{section:changes-to-undefined-behavior} describes this requirement in detail.
\item
  Pointers to objects of the same type can be subtracted. The pointers do not have to be
  the same kind of
  pointer. The result of subtracting pointers to different objects of
  the same type must be defined. Section~\ref{section:changes-to-undefined-behavior}
  describes this requirement in detail.
\end{itemize}

\section{New kinds of array types}

\ins{TODO: I'm leaving this section as-is, since checked arrays are still mysterious to me.}

A new checked array type is added to C. Just as there are checked pointer
types, there are checked array types. They are declared by placing the
modifier \keyword{checked} before the declaration of the bound of the
array\footnote{We can just as easily adopt the syntax that the checked
annotation is postfix and propagates from the inner most array to the
 outermost array. We have chosen the prefix syntax because the notation
 can be read easily from left to right ``this is a checked array of
 10x10 elements''.}:
\begin{lstlisting}
int a checked[10];
\end{lstlisting}

All array references to checked array types are bounds checked. C has
the rule that an ``array of \var{T}'' is converted implicitly to a
``pointer to \var{T}'' in a number of situations. This rule is extended
to convert a ``checked array of \var{T}'' to an ``\arrayptr\
to \var{T}''.

In C, array types may be complete or incomplete. A complete array type
specifies the bound of each dimension of the array using constant
expressions. An incomplete array type does not specify the bound of the
first dimension of the array. Examples of complete array types are
\lstinline+int[10]+ and \lstinline+int[10][10]+. Examples of
incomplete array types are \lstinline+int[]+ and \lstinline+int[][10]+.

If a checked array type is incomplete, there must be an associated
declaration of the valid bounds for the first dimension of the array.
For a complete array type, the bounds declared by the type are used to
bounds check array references. For example, given a declaration
\lstinline{int a[10]} and a use \lstinline{a[i]}, the bounds check is
that \lstinline{i >= 0} and \lstinline{i < 10}.

Array references to multi-dimensional arrays must be uniformly bounds
checked or not bounds checked. If any dimension is bounds checked, all
dimensions must be checked. A programmer can simply declare that
the outer dimension of an array is checked.  The checked property will be
propagated to the inner dimensions:

\begin{lstlisting}
int b checked[10][10];
\end{lstlisting}

In C, multidimensional arrays are arrays of arrays,
where the nested array types have known dimensions at compile-time. A
2-dimensional array is an array of array of T, a 3-dimensional array is
an array of array of array of T. The checked property is propagated from the
outer array to the nested array types.

\subsection{An example}

It is easy to convert a function that operates only on complete array
types to one where array accesses are bounds checked: just add the
\keyword{checked} keyword to the declarations of the variables with complete array
types. Consider a method that adds 2x2 integer arrays \lstinline+a+ and
\lstinline+b+ so that \lstinline+a+ = \lstinline+a+ + \lstinline+b+:

\begin{lstlisting}
void add(int a checked[2][2], int b checked[2][2]) {
  for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 2; j++) {
      a[i][j] += b[i][j];
    }
  }
}
\end{lstlisting}

\subsection{Propagation of checked property to nested array types}
The checked property of an array type is propagated to a nested array type as follows.
A declaration of a variable has the form \var{T} \var{D},
where \var{T} is a type and \var{D} is a declarator. The declarator
can be as simple as an identifier \lstinline+x+:
\begin{lstlisting}
int x;
\end{lstlisting}
It can be a more complex form that declares an identifier and modifies \var{T}
to produce a new type for the identifier. An example is \lstinline+x[5]+:
\begin{lstlisting}
int x[5];
\end{lstlisting}

Given a declaration \var{T} \var{D}, if \var{D} is an array
declarator, it will have the form
\var{D1}\lstinline|[|\var{constant-expression\textsubscript{opt}}\lstinline|]|
where \var{D1} is another declarator. The type of the identifier in the
declaration \var{T D1} will be determined first. The type can be some
constructed type of the form \var{type-modifier} of \var{T}, where
\var{type-modifier} is a sequence of array, checked array, or pointer
type modifiers. If the first element in the \var{type-modifier}
sequence is an array or pointer, the type of the identifier will be
\var{type-modifier} ``array of  \var{T}''. If the first element in the
\var{type-modifier} sequence is a checked array, the type of the
identifier will be \var{type-modifier} ``checked array of \var{T}.''

For example, in parsing the declaration of \lstinline+b+, \var{D1}
will be \lstinline+int b checked[10]+. The type of \lstinline+b+ in
\var{D1} is ``checked array of int''. The type of \lstinline+b+ in
\lstinline+int b checked[10][10]+ will be ``checked array of
checked array of int''.

\subsection{Propagation and type definitions}

A \keyword{typedef} declaration defines a name for a type. This name
can be used to declare multi-dimensional arrays:
\begin{lstlisting}
typedef int arr_ty[10];
arr_ty x[10];
\end{lstlisting}
The checked property is propagated only to array declarators that are
nested directly within other array declarators.   It is not propagated to
the bodies of type definitions.  It is an error if an array type and a nested
array type from the use of a type name have different checked properties.

Here are examples of correct and incorrect declarations:
\begin{lstlisting}
typedef int t1 checked[10];
t1 x checked[10];  // correct: checked properties match

typedef int t2[10];
t2 x checked[10];  // error: mismatched checked properties
\end{lstlisting}

\section{Initialization}

\ins{Haven't really addressed the subtlety of declaring an array pointer with no bounds.}
\ins{The following examples could also be confusing since we haven't formally introduced
  bounds declarations.}

A variable of type \arrayptrT must be initialized if it has declared bounds. Since an
\arrayptrT which does not have bounds cannot be used to access memory, it need not be
initialized.

Here are examples of variable declarations with initializers:
\begin{lstlisting}
array_ptr<int> q : count(5) = 0;  // has bounds; initializer required.
array_ptr<int> lower, upper;      // no bounds; initializer not required.
lower = q;
upper = q + 5;

struct VariableBuffer {
  array_ptr<int> buf : count(len);
  int len;
};

struct Range {
  array_ptr<int> lower;
  array_ptr<int> upper;
};

struct VariableBuffer buf = { 0 };  // initializer for struct required.
struct Range pair;                  // no bounds on members; initializer not required.
ptr<int> data checked[10] = { 0 };  // initializer for array required.
struct VariableBuffer stack checked[10] = { 0 }; // initializer for array required.
\end{lstlisting}

For heap-allocated data that contains checked pointers that may be used to access memory, the
data must be zero-initialized by the programmer.  We recommend that programmers use
\lstinline+calloc+ instead of \lstinline+malloc+ for heap-allocating data containing checked pointers.

\ins{Is this a recommendation or a requirement? I.e. could I choose to to use malloc + memset?}

\section{Relative alignment of \arrayptr\ values}
\label{section:relative-alignment}

\arrayptrT\ pointers provide
pointer arithmetic on arrays. The bounds for these pointers usually
describe a range of memory that is exactly the size of some array of \var{T}.
The pointers point to an element of the array. In other words, the lower
bound, the upper bound, and pointer are  relatively aligned to the type
\var{T}. Given a lower bound \var{lb}, an upper bound \var{ub}, and a
pointer \var{p}, there should exist some integer \var{count} such that
\var{ub} = \var{lb} + \var{count}. In addition, there is either some
integer \var{index} such that \var{p} = \var{lb} + \var{index},
where addition is C pointer arithmetic, or \var{p} is null.

The type to which a pointer and its bounds are relatively aligned is
called the relative alignment type. By default, the relative alignment
type for a pointer and its bounds is the referent type. However, the
relative alignment type can be overridden by specifying it explicitly as
part of the bounds.  This is described in
Section~\ref{section:representing-relative-alignment}.
This can be used for bounds for the results of pointers casts and
for  \arrayptrvoid\ pointers. The type
\void\ has no defined size, so the default relative alignment is
undefined for \void.

\section{Pointer arithmetic error conditions}
\label{section:pointer-arithmetic-errors}

For existing unchecked C pointers, the definition of pointer arithmetic is
described in terms of addresses of elements of an array object. The C
Standard \cite{ISO2011} states, that given a pointer p that points to some element i of
an array object, p + j points to the (i+j)th element of that object.
Pointer arithmetic is defined only for pointers to elements of the array
object or one past the last element of the array object.

We take an alternative approach to defining the meaning of pointer
arithmetic and the error conditions for pointer arithmetic. Pointer
arithmetic is allowed to go out-of-bounds and has a well-defined
semantics. Section~\ref{section:new-pointer-types-semantics}
defines the semantics of the new pointer types
directly in terms of byte addresses, instead of with respect to
addresses of elements of an array. Pointer arithmetic that overflows or
involves a null pointer is defined to produce a runtime error.

The new pointer types allow pointer arithmetic that produces
out-of-bounds values. The C definition leaves pointer arithmetic that
produces out-of-bounds values undefined because it is not clear what the
meaning of should be when the pointers are dereferenced. The new pointer
types prevent out-of-bounds pointers from being dereferenced, and solve
this problem another way. In addition, in practice C implementations
often allow pointer arithmetic to produce out-of-bounds values and C
programs end up relying on this implementation-specific behavior. There
is no reason to cause existing code that computes out-of-bounds pointers
but does not dereference them to break when it is converted to use the
new pointer types.

When pointer arithmetic overflows or involves a null pointer, the
resulting value of the expression cannot be used and program execution
stops. If a system provides for error handling, an error handling
mechanism may be invoked to redirect program execution to a new point of
execution that does not use the value of the expression.

Defining pointer arithmetic this way simplifies reasoning about the new
pointer types. Expected identities such as \code{p + 1 > p} now hold
because, if \code{p + 1} overflows, the value cannot be
used. This allows programmers to narrow the bounds for
\arrayptr\ values by incrementing the lower bound or
decrementing the upper bound, even in situations where the bounds are at
the ends of the address space. Later sections describe places where
allowing an undefined value to be used would complicate reasoning about
programs.

If a compiler cannot prove that a new pointer type value is non-null
before a pointer arithmetic operation, it must insert a check.
Similarly, if a compiler cannot prove that a pointer arithmetic
expression for a new pointer type cannot overflow, it must insert a
check. This may slow a typical program down by a slight amount.

\subsection{Semantics of pointer arithmetic for new pointer types}
\label{section:new-pointer-types-semantics}

This section defines the semantics of pointer arithmetic and explains
when overflow occurs in pointer arithmetic. It is assumed that memory is
addressable at the byte level. The order of bits within a byte is not
specified. The order of bytes within built-in types larger than a byte,
such as integers and floating-point numbers, is also not specified.
Pointers shall be treated as addresses of locations of bytes in memory.
The addresses shall be unsigned integers with a defined range of 0 to
\code{UINTPTR_MAX}. The maximum value of a signed integer that can be
added to an address shall be given by \code{INTPTR_MAX} and the
minimum value of a signed integer that can be added to an address shall
be given by \code{INTPTR_MIN}.

For the new
\arrayptrT\ pointer
types, there are distinct operations for addition and subtraction of
pointers by signed and unsigned integers. The operations behave
similarly, but have different overflow conditions for scaling because
the ranges of signed integers and unsigned integers are different.

\begin{itemize}
\item
  First scaling an integer by \sizeof{\var{T}} is
  defined. To scale an integer \var{i}, \var{i} shall be multiplied by
  \sizeof{\var{T}}, producing an integer \var{j}. If
  \var{i} is a signed integer, the scaled result shall be treated as a
  signed integer. If \var{i} is an unsigned integer, the scaled result
  shall be treated as an unsigned integer. For a signed integer, the
  minimum and maximum range for \var{j} shall be \code{INTPTR_MIN} and
  \code{INTPTR_MAX} For an unsigned integer, the minimum and maximum
  range for \var{j} shall be 0 and \code{UINTPTR_MAX}. If \var{j} is
  outside its valid range, the operation doing the scaling operation
  shall produce a runtime error.
\item
  \var{p} \code{+} \var{i}, where \var{p} is an
  \arrayptrT\ pointer
  and \var{i} is an integer. The integer \var{i} shall be scaled by
  \sizeof{\var{T}}, producing an integer \var{j}. The
  pointer \var{p} will be interpreted as an unsigned integer. The mathematical
  value \var{p} + \var{j} shall be the result of the operation. If
  \var{p} + \var{j} is out of range for a pointer, the operation shall
  produce a runtime error.
\item
  \var{i} \code{+} \var{p}, where \var{p} is an
  \arrayptrT\ pointer
  and \var{i} is an integer, shall be defined as \var{p} \code{+}
  \var{i}.
\item
  \var{p} \code{-} \var{i}, where \var{p} is an
  \arrayptrT\ pointer
  and \var{i} is an integer. The integer \var{i} shall be scaled by
  \sizeof{\var{T}}, producing an integer \var{j}. The
  pointer \var{p} will be interpreted as an unsigned integer. The
  mathematical value \var{p} - \var{j} shall be the result of the
  operation. If \var{p -} \var{j} is out of range for a pointer, the
  operation shall produce a runtime error.
\item
  \var{p} \code{-} \var{q}, where \var{p} and \var{q} are
  \arrayptrT\
  pointers. The two pointers will be interpreted as unsigned integers
  and the mathematical value \var{p} - \var{q} shall be computed,
  producing an integer \var{j}. If \var{j} is out of range for signed
  integer that can be added to an address, the operation shall produce a
  runtime error. If \var{j} is a multiple of
  \sizeof{\var{T}}, the result shall be
  \var{j}/\sizeof{\var{T}}. If \var{j} is not a
  multiple of \sizeof{\var{T}}, then the value shall
  be determined as follows:

  \begin{itemize}
  \item
    If \var{j} is non-negative,
    \var{j}/\sizeof{\var{T}} shall round toward 0.
  \item
    If \var{j} is negative, it shall be implementation-defined whether
    \var{j}/\sizeof{\var{T}} rounds toward 0 or away
    from 0.
  \end{itemize}
\end{itemize}

An important implication of these definitions is that they put a maximum
limit on the number of elements in an array of type \var{T}. It is
\code{UINTPTR_MAX/}\sizeof{\var{T}}. They also put
maximum limits on the number of elements that can be accessed in an
array by a signed integer or an unsigned integer. That leads to limits
on the size of arrays that can be described by some bounds. A signed
integer that must be non-negative can describe an array of
\code{INTPTR_MAX/}\sizeof{var{T}} elements.

\subsection{Expressing pointer arithmetic as integer arithmetic}
\label{section:pointers-as-integers}

During static checking, pointer arithmetic operations will be converted
to use integer arithmetic. This is necessary in C because at times
programmers do explicit size computations that follow the same rules as
pointer arithmetic.

To support this expansion, integer arithmetic operators are extended
with the operators \plusovf, \minusovf, and \mulovf. The
operators interpet pointers as unsigned integers in some range 0 to
\code{UINTPTR_MAX}. An operator produces a runtime error if the value
of its result cannot be represented by the result type:

\begin{itemize}
\item
  \plusovf\ takes an unsigned integer \var{i} and an
  integer \var{j} and produces an unsigned integer in the range 0 to
  \code{UINTPTR_MAX}. Its result is the mathemetical value \var{i} + \var{j}.
\item
  For subtraction, there are two forms:

  \begin{itemize}
  \item
    \minusovf\ takes an unsigned integer \var{i} and an
    integer \var{j} as an argument and computes \var{i} - \var{j}, producing an unsigned
    integer in the range 0 to \code{UINTPTR_MAX}. Its result is the
    mathematical value \var{i} - \var{j}.
  \item
    \lstinline|-|\textsubscript{ovf\_diff } takes two unsigned integers \var{i}
    and \var{j} and computes \var{i} - \var{j}, producing a signed integer of type
    \code{ptrdiff_t}. Its result is the mathemetical value \var{i} - \var{j}.
  \end{itemize}
\item
  \mulovf\ takes two integers \var{i} and \var{j} (both either
  signed or unsigned) as arguments. It produces an integer whose type is
  the same as the input argument types. Its result is the mathematical
  value \var{i} * \var{j}.
\end{itemize}

Given an expression \code{e1} with a pointer type and an expression
\code{e2} with an integer type, the expansion of \code{e1 + e2} from
pointer arithmetic to integer arithmetic depends on the type of
\code{e2}. The number of bytes to added must be the same kind of
signed or unsigned integer as \code{e2}.

\begin{itemize}
\item
  If \code{e2} is an unsigned integer, \code{e1 + e2} expands to
  \code{e1} \plusovf\ \sizeof{\var{T}} \mulovf\ \code{e2}.
\item
  If \code{e2} is a signed integer, the expansion of \code{e1 + e2}
  must cast \sizeof{\var{T}} to a signed integer. We introduce a
  signed integer type \code{signed_size_t} that is large enough for
  this cast. \code{e1 + e2} expands to \code{e1} \plusovf\
  \code{((signed_size_t)} \sizeof{\var{T}}\code{)} \mulovf\ \code{e2}. This cast is
  necessary because in C, multiplying a signed integer by an unsigned
  integer implicitly converts the signed integer to be an unsigned
  integer.
\end{itemize}
